rules:
  - name: NestJS Security Analysis
    description: Identify sensitive files, check .gitignore coverage, analyze authentication/authorization patterns, and find dependency scanning configuration for NestJS projects.
    match: "*"
    prompt: |
      Goal: Identify sensitive files, check .gitignore coverage, analyze security patterns, and find dependency scanning configuration for single app or monorepo repositories.

      IMPORTANT EXCLUSIONS:
      - Do NOT analyze, recommend, or consider missing SECURITY.md files
      - Do NOT analyze, recommend, or consider missing CODEOWNERS files
      - These are governance decisions, not technical security requirements
      - Focus only on technical security issues

      MONOREPO DETECTION:
      - First detect repository structure: single app or monorepo
      - If apps/ directory exists, analyze each app individually
      - If packages/ or libs/ directory exists, analyze each package/library individually

      SENSITIVE FILES DETECTION:

      1. Environment Files:
         - Find all .env files (should NOT be in repo):
           * .env
           * .env.local
           * .env.development
           * .env.production
           * .env.staging
           * .env.test
         - Verify .env files are in .gitignore
         - Check for .env.example (should exist)
         - Verify .env.example has no actual secrets
         
      2. Credentials and Keys:
         - Search for potential credential files:
           * **/secrets/**
           * **/credentials/**
           * **/*.pem, **/*.key, **/*.cert
           * **/*-key.json, **/*-credentials.json
           * **/service-account*.json
         - Check if found files are in .gitignore
         - Scan for hardcoded secrets in code (API keys, passwords)
         
      3. Database Configuration:
         - Check for database connection strings in code
         - Verify database passwords not hardcoded
         - Check ormconfig.json (should not have production credentials)
         - Verify .env is used for database configuration
         
      4. JWT and Session Secrets:
         - Check for JWT_SECRET, SESSION_SECRET in .env.example
         - Verify secrets not hardcoded in code
         - Check for proper secret generation

      .GITIGNORE ANALYSIS:

      1. Root .gitignore:
         - Verify essential patterns:
           * node_modules
           * dist / build
           * .env*  (with !.env.example)
           * *.log
           * coverage
           * .vscode (optional, team preference)
           * .idea (optional, team preference)
         
      2. Security-Specific Patterns:
         - Environment files: .env*
         - Credentials: *.pem, *.key, *.cert, *credentials*.json
         - Database files: *.db, *.sqlite, *.sqlite3
         - Debug files: npm-debug.log*, yarn-debug.log*, yarn-error.log*
         - OS files: .DS_Store, Thumbs.db
         
      3. Multi-App .gitignore (if monorepo):
         - Check for app-specific .gitignore files
         - Verify app-specific sensitive files are ignored
         - Compare patterns across apps

      AUTHENTICATION & AUTHORIZATION ANALYSIS:

      1. Authentication Strategy:
         - Check for auth module (src/auth/)
         - Identify authentication methods:
           * JWT (@nestjs/jwt)
           * Passport (@nestjs/passport)
           * Local strategy (passport-local)
           * OAuth2 (passport-oauth2, passport-google-oauth20, etc.)
           * Session-based (express-session)
         - Verify password hashing:
           * bcrypt or bcryptjs usage
           * argon2 usage (more secure alternative)
           * Proper salt rounds (10+ for bcrypt)
         
      2. Authorization Patterns:
         - Check for guards:
           * JwtAuthGuard
           * RolesGuard
           * PermissionsGuard
         - Verify @UseGuards() usage on controllers/routes
         - Check for role-based access control (RBAC):
           * @Roles() decorator
           * Role enum or constants
           * Role checking logic
         - Check for attribute-based access control (ABAC)
         - Verify public routes are explicitly marked (@Public decorator)
         
      3. Token Management:
         - Check JWT configuration:
           * Secret management (from environment)
           * Token expiration settings
           * Refresh token implementation
         - Verify token validation
         - Check for token blacklisting (if needed)
         - Verify secure token storage recommendations (frontend)

      SECURITY BEST PRACTICES:

      1. CORS Configuration:
         - Check main.ts for app.enableCors()
         - Verify CORS configuration:
           * origin: specific domains (not '*' in production)
           * credentials: true (if using cookies)
           * methods: specific methods
         - Check for environment-based CORS config
         
      2. Helmet Integration:
         - Check for helmet package
         - Verify app.use(helmet()) in main.ts
         - Check custom helmet configuration
         
      3. Rate Limiting:
         - Check for @nestjs/throttler
         - Verify ThrottlerModule configuration:
           * ttl (time to live)
           * limit (request limit)
         - Check for custom rate limiters
         - Verify rate limiting on sensitive endpoints (login, register, etc.)
         
      4. CSRF Protection:
         - Check for csurf or @nestjs/csrf
         - Verify CSRF protection on state-changing operations
         - Check for SameSite cookie attribute
         
      5. Input Validation:
         - Verify global ValidationPipe usage
         - Check whitelist: true (strips unknown properties)
         - Check forbidNonWhitelisted: true
         - Verify sanitization for XSS prevention
         
      6. SQL Injection Prevention:
         - Verify parameterized queries (ORM usage)
         - Check for raw queries (flag for review)
         - Verify input validation before database operations
         
      7. File Upload Security:
         - Check for file upload handling
         - Verify file type validation
         - Check file size limits
         - Verify filename sanitization
         - Check for virus scanning (if applicable)

      DEPENDENCY SECURITY:

      1. Dependency Scanning:
         - Check for npm audit in CI/CD
         - Check for Snyk integration
         - Verify Dependabot configuration (.github/dependabot.yaml or .github/dependabot.yml)
         - Check for automated security updates
         
      2. Package Integrity:
         - Check for package-lock.json integrity
         - Verify npm ci usage in CI/CD (not npm install)
         - Check for exact versions (no ^ or ~) for critical packages
         
      3. Vulnerability Remediation:
         - Check for known vulnerabilities (npm audit output)
         - Identify high/critical vulnerabilities
         - Check for available patches

      SECRETS MANAGEMENT:

      1. Environment Variables:
         - Verify @nestjs/config usage
         - Check ConfigModule setup:
           * load from .env
           * validation schema (Joi)
           * cache configuration
         - Verify process.env not used directly (use ConfigService)
         
      2. Secrets Vaults (if applicable):
         - Check for AWS Secrets Manager integration
         - Check for HashiCorp Vault integration
         - Check for Azure Key Vault integration
         
      3. Development vs Production:
         - Verify different configs for environments
         - Check for NODE_ENV usage
         - Verify production has stricter security settings

      OWASP TOP 10 CHECKLIST:

      1. A01: Broken Access Control
         - Verify authorization guards on all protected routes
         - Check for proper role/permission validation
         
      2. A02: Cryptographic Failures
         - Verify HTTPS enforcement
         - Check for proper password hashing
         - Verify sensitive data encryption at rest
         
      3. A03: Injection
         - Verify input validation on all endpoints
         - Check for parameterized queries (ORM)
         - Verify output encoding
         
      4. A04: Insecure Design
         - Check for security by design patterns
         - Verify threat modeling evidence
         
      5. A05: Security Misconfiguration
         - Verify security headers (helmet)
         - Check for debug mode disabled in production
         - Verify error messages don't expose internals
         
      6. A06: Vulnerable Components
         - Check dependency vulnerabilities (npm audit)
         - Verify dependencies are up-to-date
         
      7. A07: Authentication Failures
         - Verify strong password requirements
         - Check for brute force protection (rate limiting)
         - Verify session management
         
      8. A08: Software and Data Integrity
         - Verify CI/CD pipeline security
         - Check for code signing (if applicable)
         
      9. A09: Logging Failures
         - Verify security events are logged
         - Check for log sanitization (no sensitive data)
         - Verify log retention policies
         
      10. A10: Server-Side Request Forgery (SSRF)
          - Check for URL validation on user inputs
          - Verify allowlist for external requests

      MULTI-APP MONOREPO SECURITY:
      - Root-level security:
        * Check root .env handling
        * Verify shared security utilities
        * Check for centralized auth packages
      - Per-app security:
        * For each app in apps/ directory:
          - Check app-specific .env handling
          - Verify authentication implementation
          - Check authorization patterns
          - Verify security best practices
      - Cross-app security consistency:
        * Compare security patterns across apps
        * Verify consistent auth implementation
        * Check for shared security configurations

      Output format:
      - Repository structure type (single app / monorepo)
      - Sensitive files detected and protection status (per app if monorepo)
      - .gitignore coverage analysis (per app if monorepo)
      - Authentication strategy detected (per app if monorepo)
      - Authorization patterns found (per app if monorepo)
      - Security best practices compliance (per app if monorepo)
      - Dependency security status (vulnerabilities count)
      - Secrets management approach (per app if monorepo)
      - OWASP Top 10 coverage (per app if monorepo)
      - Security risks identified (per app if monorepo)
      - Missing security configurations (per app if monorepo)
      - Recommendations for improvement (per app if monorepo)
      - Security consistency across apps (if monorepo)
      
      CRITICAL: Do NOT report missing SECURITY.md or CODEOWNERS files as security risks or missing configurations.
      These are governance decisions, not technical security requirements.


